import{_ as e,C as u,c as p,o as a,a2 as g,b as r,j as i,w as t,a as h,G as c,a3 as l}from"./chunks/framework.nRfFlDZQ.js";const k=JSON.parse('{"title":"Chương 2: Kiến trúc Convolutional Neural Network Cơ bản","description":"","frontmatter":{},"headers":[],"relativePath":"chuong-02-co-so-ly-thuyet/muc-01-kien-truc-cnn/01-kien-truc-co-ban.md","filePath":"chuong-02-co-so-ly-thuyet/muc-01-kien-truc-cnn/01-kien-truc-co-ban.md","lastUpdated":1766163869000}'),s={name:"chuong-02-co-so-ly-thuyet/muc-01-kien-truc-cnn/01-kien-truc-co-ban.md"};function d(m,n,A,C,B,b){const o=u("Mermaid");return a(),p("div",null,[n[16]||(n[16]=g('<h1 id="chuong-2-kien-truc-convolutional-neural-network-co-ban" tabindex="-1">Chương 2: Kiến trúc Convolutional Neural Network Cơ bản <a class="header-anchor" href="#chuong-2-kien-truc-convolutional-neural-network-co-ban" aria-label="Permalink to &quot;Chương 2: Kiến trúc Convolutional Neural Network Cơ bản&quot;">​</a></h1><h2 id="_2-1-tong-quan-ve-kien-truc-cnn" tabindex="-1">2.1. Tổng quan về Kiến trúc CNN <a class="header-anchor" href="#_2-1-tong-quan-ve-kien-truc-cnn" aria-label="Permalink to &quot;2.1. Tổng quan về Kiến trúc CNN&quot;">​</a></h2><p>Convolutional Neural Network (CNN) là một kiến trúc mạng nơ-ron được thiết kế đặc biệt để xử lý dữ liệu có cấu trúc không gian, điển hình là ảnh số. Khác với mạng nơ-ron fully connected truyền thống vốn xử lý đầu vào như một vector phẳng, CNN bảo toàn cấu trúc không gian của dữ liệu thông qua việc sử dụng các phép toán convolution. Điều này cho phép mạng học được các đặc trưng có ý nghĩa về mặt không gian như cạnh, góc, kết cấu, và hình dạng đối tượng.</p><h3 id="_2-1-1-tai-sao-can-cnn-thay-vi-mang-fully-connected" tabindex="-1">2.1.1. Tại sao cần CNN thay vì mạng Fully Connected? <a class="header-anchor" href="#_2-1-1-tai-sao-can-cnn-thay-vi-mang-fully-connected" aria-label="Permalink to &quot;2.1.1. Tại sao cần CNN thay vì mạng Fully Connected?&quot;">​</a></h3><p>Việc sử dụng Multilayer Perceptron (MLP) cho xử lý ảnh gặp phải vấn đề nghiêm trọng về số lượng tham số [1]. Xét một ảnh có kích thước khiêm tốn 100×100 pixel với 3 kênh màu RGB, ta có 30,000 giá trị đầu vào. Nếu sử dụng một lớp ẩn với 1,000 nơ-ron, số lượng tham số kết nối đã lên tới 30 triệu. Với ảnh có độ phân giải cao hơn trong viễn thám (hàng nghìn pixel mỗi chiều), con số này trở nên không thể xử lý được.</p>',5)),(a(),r(l,null,{default:t(()=>[c(o,{id:"mermaid-15",class:"mermaid",graph:"graph%20LR%0A%20%20%20%20subgraph%20%22MLP%3A%2030%20tri%E1%BB%87u%20tham%20s%E1%BB%91%22%0A%20%20%20%20%20%20%20%20A%5B%22%E1%BA%A2nh%20100%C3%97100%C3%973%3Cbr%2F%3E%3D%2030%2C000%20pixel%22%5D%20--%3E%20B%5B%22Flatten%20th%C3%A0nh%3Cbr%2F%3Evector%201D%22%5D%0A%20%20%20%20%20%20%20%20B%20--%3E%20C%5B%22Fully%20Connected%3Cbr%2F%3E1%2C000%20neurons%22%5D%0A%20%20%20%20end%0A%20%20%20%20subgraph%20%22CNN%3A%20V%C3%A0i%20tr%C4%83m%20tham%20s%E1%BB%91%22%0A%20%20%20%20%20%20%20%20D%5B%22%E1%BA%A2nh%20100%C3%97100%C3%973%22%5D%20--%3E%20E%5B%22Kernel%203%C3%973%C3%973%3Cbr%2F%3E%3D%2027%20params%22%5D%0A%20%20%20%20%20%20%20%20E%20--%3E%20F%5B%22Feature%20Map%22%5D%0A%20%20%20%20end%0A"})]),fallback:t(()=>[...n[0]||(n[0]=[h(" Loading... ",-1)])]),_:1})),n[17]||(n[17]=i("p",null,"CNN giải quyết vấn đề này dựa trên hai nguyên lý quan trọng:",-1)),n[18]||(n[18]=i("p",null,[i("strong",null,"Tính bất biến với phép tịnh tiến (Translation Invariance):"),h(" Một đặc trưng có ý nghĩa (ví dụ: cạnh của tàu biển) nên được nhận dạng bất kể nó xuất hiện ở vị trí nào trong ảnh. CNN đạt được điều này bằng cách sử dụng cùng một bộ lọc trượt qua toàn bộ ảnh, thay vì học các tham số riêng biệt cho từng vị trí.")],-1)),n[19]||(n[19]=i("p",null,[i("strong",null,"Tính cục bộ (Locality):"),h(' Các đặc trưng thị giác cơ bản như cạnh, góc, và kết cấu phụ thuộc vào các pixel lân cận, không phụ thuộc vào các pixel ở xa. CNN khai thác điều này bằng cách hạn chế mỗi nơ-ron chỉ "nhìn thấy" một vùng nhỏ của ảnh đầu vào, gọi là receptive field cục bộ.')],-1)),n[20]||(n[20]=i("h3",{id:"_2-1-2-cau-truc-phan-cap-cua-cnn",tabindex:"-1"},[h("2.1.2. Cấu trúc phân cấp của CNN "),i("a",{class:"header-anchor",href:"#_2-1-2-cau-truc-phan-cap-cua-cnn","aria-label":'Permalink to "2.1.2. Cấu trúc phân cấp của CNN"'},"​")],-1)),n[21]||(n[21]=i("p",null,"Một mạng CNN điển hình được cấu thành từ nhiều lớp xếp chồng lên nhau, mỗi lớp thực hiện một phép biến đổi cụ thể. Kiến trúc này có thể được hình dung như một pipeline xử lý phân cấp:",-1)),(a(),r(l,null,{default:t(()=>[c(o,{id:"mermaid-31",class:"mermaid",graph:"graph%20TB%0A%20%20%20%20subgraph%20%22%C4%90%E1%BA%A7u%20v%C3%A0o%22%0A%20%20%20%20%20%20%20%20A%5B%22%E1%BA%A2nh%20g%E1%BB%91c%3Cbr%2F%3EH%C3%97W%C3%97C%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22Tr%C3%ADch%20xu%E1%BA%A5t%20%C4%91%E1%BA%B7c%20tr%C6%B0ng%20c%E1%BA%A5p%20th%E1%BA%A5p%22%0A%20%20%20%20%20%20%20%20B%5B%22Conv%20%2B%20ReLU%20%2B%20Pool%22%5D%0A%20%20%20%20%20%20%20%20B1%5B%22%C4%90%E1%BA%B7c%20tr%C6%B0ng%3A%20c%E1%BA%A1nh%2C%20gradient%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22Tr%C3%ADch%20xu%E1%BA%A5t%20%C4%91%E1%BA%B7c%20tr%C6%B0ng%20c%E1%BA%A5p%20trung%22%0A%20%20%20%20%20%20%20%20C%5B%22Conv%20%2B%20ReLU%20%2B%20Pool%22%5D%0A%20%20%20%20%20%20%20%20C1%5B%22%C4%90%E1%BA%B7c%20tr%C6%B0ng%3A%20k%E1%BA%BFt%20c%E1%BA%A5u%2C%20pattern%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22Tr%C3%ADch%20xu%E1%BA%A5t%20%C4%91%E1%BA%B7c%20tr%C6%B0ng%20c%E1%BA%A5p%20cao%22%0A%20%20%20%20%20%20%20%20D%5B%22Conv%20%2B%20ReLU%20%2B%20Pool%22%5D%0A%20%20%20%20%20%20%20%20D1%5B%22%C4%90%E1%BA%B7c%20tr%C6%B0ng%3A%20b%E1%BB%99%20ph%E1%BA%ADn%20%C4%91%E1%BB%91i%20t%C6%B0%E1%BB%A3ng%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22Ph%C3%A2n%20lo%E1%BA%A1i%22%0A%20%20%20%20%20%20%20%20E%5B%22Global%20Pooling%22%5D%0A%20%20%20%20%20%20%20%20F%5B%22Fully%20Connected%22%5D%0A%20%20%20%20%20%20%20%20G%5B%22Softmax%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20A%20--%3E%20B%20--%3E%20B1%0A%20%20%20%20B1%20--%3E%20C%20--%3E%20C1%0A%20%20%20%20C1%20--%3E%20D%20--%3E%20D1%0A%20%20%20%20D1%20--%3E%20E%20--%3E%20F%20--%3E%20G%0A"})]),fallback:t(()=>[...n[1]||(n[1]=[h(" Loading... ",-1)])]),_:1})),n[22]||(n[22]=g('<p>Các lớp đầu học được các đặc trưng cấp thấp như cạnh theo nhiều hướng và thay đổi cường độ sáng. Các lớp giữa kết hợp các đặc trưng cấp thấp để tạo thành các pattern phức tạp hơn như kết cấu bề mặt nước hay góc của công trình. Các lớp sâu hơn học được các đặc trưng ngữ nghĩa cao như hình dạng tàu biển hay vùng dầu loang.</p><h2 id="_2-2-phep-toan-tuong-quan-cheo-cross-correlation" tabindex="-1">2.2. Phép toán Tương quan chéo (Cross-Correlation) <a class="header-anchor" href="#_2-2-phep-toan-tuong-quan-cheo-cross-correlation" aria-label="Permalink to &quot;2.2. Phép toán Tương quan chéo (Cross-Correlation)&quot;">​</a></h2><h3 id="_2-2-1-đinh-nghia-va-cong-thuc" tabindex="-1">2.2.1. Định nghĩa và Công thức <a class="header-anchor" href="#_2-2-1-đinh-nghia-va-cong-thuc" aria-label="Permalink to &quot;2.2.1. Định nghĩa và Công thức&quot;">​</a></h3><p>Phép toán cốt lõi trong lớp convolution thực chất là <strong>tương quan chéo (cross-correlation)</strong> chứ không phải tích chập (convolution) theo nghĩa toán học thuần túy [1]. Tuy nhiên, trong lĩnh vực học sâu, hai thuật ngữ này thường được sử dụng thay thế cho nhau do sự khác biệt chỉ nằm ở việc lật kernel, điều không ảnh hưởng đến khả năng học của mạng.</p><p>Xét đầu vào là ma trận hai chiều <strong>X</strong> có kích thước n_h × n_w và bộ lọc (kernel) <strong>K</strong> có kích thước k_h × k_w. Phép tương quan chéo tạo ra output <strong>Y</strong> với kích thước:</p><p><strong>(n_h - k_h + 1) × (n_w - k_w + 1)</strong></p><p>Giá trị tại mỗi vị trí (i, j) của output được tính bằng cách:</p><ol><li>Đặt kernel chồng lên vùng tương ứng của input</li><li>Nhân từng phần tử (element-wise multiplication)</li><li>Cộng tất cả các tích lại với nhau</li></ol><h3 id="_2-2-2-minh-hoa-phep-tinh-voi-kernel-2×2" tabindex="-1">2.2.2. Minh họa Phép tính với Kernel 2×2 <a class="header-anchor" href="#_2-2-2-minh-hoa-phep-tinh-voi-kernel-2×2" aria-label="Permalink to &quot;2.2.2. Minh họa Phép tính với Kernel 2×2&quot;">​</a></h3><p>Dưới đây là ví dụ minh họa phép tương quan chéo với input 3×3 và kernel 2×2:</p>',10)),(a(),r(l,null,{default:t(()=>[c(o,{id:"mermaid-76",class:"mermaid",graph:"graph%20LR%0A%20%20%20%20subgraph%20%22Input%203%C3%973%22%0A%20%20%20%20%20%20%20%20I%5B%220%20%201%20%202%3Cbr%2F%3E3%20%204%20%205%3Cbr%2F%3E6%20%207%20%208%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22Kernel%202%C3%972%22%0A%20%20%20%20%20%20%20%20K%5B%220%20%201%3Cbr%2F%3E2%20%203%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22Output%202%C3%972%22%0A%20%20%20%20%20%20%20%20O%5B%2219%20%2025%3Cbr%2F%3E37%20%2043%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20I%20--%3E%20%7C%22%E2%8A%9B%22%7C%20K%20--%3E%20O%0A"})]),fallback:t(()=>[...n[2]||(n[2]=[h(" Loading... ",-1)])]),_:1})),n[23]||(n[23]=g('<p><strong>Tính giá trị đầu tiên (vị trí 0,0):</strong></p><ul><li>Vùng input được chọn: [[0,1], [3,4]]</li><li>Phép nhân element-wise với kernel: 0×0 + 1×1 + 3×2 + 4×3 = 0 + 1 + 6 + 12 = <strong>19</strong></li></ul><p><strong>Tính giá trị thứ hai (vị trí 0,1):</strong></p><ul><li>Kernel trượt sang phải 1 vị trí</li><li>Vùng input được chọn: [[1,2], [4,5]]</li><li>Phép tính: 1×0 + 2×1 + 4×2 + 5×3 = 0 + 2 + 8 + 15 = <strong>25</strong></li></ul><p>Tương tự, ta tính được các giá trị còn lại: 37 và 43.</p><h3 id="_2-2-3-ung-dung-phat-hien-canh" tabindex="-1">2.2.3. Ứng dụng: Phát hiện cạnh <a class="header-anchor" href="#_2-2-3-ung-dung-phat-hien-canh" aria-label="Permalink to &quot;2.2.3. Ứng dụng: Phát hiện cạnh&quot;">​</a></h3><p>Một ứng dụng kinh điển của phép convolution là phát hiện cạnh (edge detection). Xét kernel đơn giản [[1, -1]] để phát hiện cạnh dọc:</p>',7)),(a(),r(l,null,{default:t(()=>[c(o,{id:"mermaid-121",class:"mermaid",graph:"graph%20TB%0A%20%20%20%20subgraph%20%22%E1%BA%A2nh%20%C4%91%E1%BA%A7u%20v%C3%A0o%22%0A%20%20%20%20%20%20%20%20A%5B%22V%C3%B9ng%20s%C3%A1ng%20%7C%20V%C3%B9ng%20t%E1%BB%91i%3Cbr%2F%3E1%201%201%20%7C%200%200%200%3Cbr%2F%3E1%201%201%20%7C%200%200%200%3Cbr%2F%3E1%201%201%20%7C%200%200%200%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22Kernel%20%5B1%2C%20-1%5D%22%0A%20%20%20%20%20%20%20%20K%5B%22Ph%C3%A1t%20hi%E1%BB%87n%3Cbr%2F%3Echuy%E1%BB%83n%20%C4%91%E1%BB%95i%20%C4%91%E1%BB%99%20s%C3%A1ng%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22Output%22%0A%20%20%20%20%20%20%20%20O%5B%220%20%7C%201%20%7C%200%200%200%3Cbr%2F%3E0%20%7C%201%20%7C%200%200%200%3Cbr%2F%3E0%20%7C%201%20%7C%200%200%200%3Cbr%2F%3E%3Cbr%2F%3EC%E1%BA%A1nh%20d%E1%BB%8Dc%20%C4%91%C6%B0%E1%BB%A3c%3Cbr%2F%3Eph%C3%A1t%20hi%E1%BB%87n%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20A%20--%3E%20K%20--%3E%20O%0A"})]),fallback:t(()=>[...n[3]||(n[3]=[h(" Loading... ",-1)])]),_:1})),n[24]||(n[24]=g('<ul><li>Tại vùng pixel đồng nhất (đều sáng hoặc đều tối): output = 0</li><li>Tại ranh giới sáng-tối: output = 1 (hoặc -1 nếu từ tối sang sáng)</li></ul><p>Điểm mạnh của CNN nằm ở khả năng <strong>học kernel tối ưu từ dữ liệu</strong> thông qua gradient descent, thay vì phải thiết kế thủ công [1]. Các thực nghiệm cho thấy kernel được học tự động có thể hội tụ về giá trị gần với kernel thiết kế thủ công sau một số iterations nhất định.</p><h2 id="_2-3-lop-convolution-convolutional-layer" tabindex="-1">2.3. Lớp Convolution (Convolutional Layer) <a class="header-anchor" href="#_2-3-lop-convolution-convolutional-layer" aria-label="Permalink to &quot;2.3. Lớp Convolution (Convolutional Layer)&quot;">​</a></h2><h3 id="_2-3-1-cac-tham-so-quan-trong" tabindex="-1">2.3.1. Các Tham số Quan trọng <a class="header-anchor" href="#_2-3-1-cac-tham-so-quan-trong" aria-label="Permalink to &quot;2.3.1. Các Tham số Quan trọng&quot;">​</a></h3><p><strong>Kích thước bộ lọc (Kernel Size):</strong> Quyết định receptive field cục bộ của mỗi nơ-ron. Các kích thước phổ biến bao gồm 3×3, 5×5, và 7×7. Bộ lọc 3×3 được sử dụng rộng rãi nhất trong các kiến trúc hiện đại vì có thể xếp chồng nhiều lớp 3×3 để đạt được receptive field tương đương bộ lọc lớn hơn, đồng thời giảm số lượng tham số và tăng khả năng biểu diễn phi tuyến [3].</p>',5)),(a(),r(l,null,{default:t(()=>[c(o,{id:"mermaid-146",class:"mermaid",graph:"graph%20LR%0A%20%20%20%20subgraph%20%22Kernel%203%C3%973%20%C3%97%202%20l%E1%BB%9Bp%22%0A%20%20%20%20%20%20%20%20A%5B%22Input%22%5D%20--%3E%20B%5B%22Conv%203%C3%973%3Cbr%2F%3ERF%20%3D%203%22%5D%0A%20%20%20%20%20%20%20%20B%20--%3E%20C%5B%22Conv%203%C3%973%3Cbr%2F%3ERF%20%3D%205%22%5D%0A%20%20%20%20%20%20%20%20C%20--%3E%20D%5B%22Output%3Cbr%2F%3ERF%20t%E1%BB%95ng%20%3D%205%C3%975%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22Kernel%205%C3%975%20%C3%97%201%20l%E1%BB%9Bp%22%0A%20%20%20%20%20%20%20%20E%5B%22Input%22%5D%20--%3E%20F%5B%22Conv%205%C3%975%3Cbr%2F%3ERF%20%3D%205%22%5D%0A%20%20%20%20%20%20%20%20F%20--%3E%20G%5B%22Output%3Cbr%2F%3ERF%20t%E1%BB%95ng%20%3D%205%C3%975%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20style%20A%20fill%3A%23e1f5fe%0A%20%20%20%20style%20E%20fill%3A%23e1f5fe%0A"})]),fallback:t(()=>[...n[4]||(n[4]=[h(" Loading... ",-1)])]),_:1})),n[25]||(n[25]=g('<p><strong>So sánh số tham số:</strong></p><ul><li>2 lớp Conv 3×3: 2 × (3×3) = 18 tham số + thêm 1 ReLU</li><li>1 lớp Conv 5×5: 5×5 = 25 tham số</li></ul><p>Như vậy, việc xếp chồng kernel nhỏ không chỉ tiết kiệm tham số mà còn tăng khả năng biểu diễn phi tuyến nhờ các hàm kích hoạt xen kẽ giữa các lớp.</p><h3 id="_2-3-2-padding-đem" tabindex="-1">2.3.2. Padding (Đệm) <a class="header-anchor" href="#_2-3-2-padding-đem" aria-label="Permalink to &quot;2.3.2. Padding (Đệm)&quot;">​</a></h3><p>Khi áp dụng kernel k×k lên input n×n, output có kích thước (n-k+1)×(n-k+1), tức nhỏ hơn input. Sau nhiều lớp convolution liên tiếp, kích thước không gian giảm nhanh chóng và có thể dẫn đến mất thông tin ở biên ảnh.</p><p><strong>Padding</strong> là kỹ thuật thêm các pixel (thường có giá trị 0) vào viền ảnh đầu vào để kiểm soát kích thước output. Với padding p (mỗi bên), kích thước output trở thành:</p><p><strong>(n_h - k_h + 2p + 1) × (n_w - k_w + 2p + 1)</strong></p>',7)),(a(),r(l,null,{default:t(()=>[c(o,{id:"mermaid-177",class:"mermaid",graph:"graph%20TB%0A%20%20%20%20subgraph%20%22Kh%C3%B4ng%20c%C3%B3%20padding%22%0A%20%20%20%20%20%20%20%20A%5B%22Input%208%C3%978%3Cbr%2F%3EKernel%203%C3%973%22%5D%20--%3E%20B%5B%22Output%206%C3%976%3Cbr%2F%3E(gi%E1%BA%A3m%202%20pixel%20m%E1%BB%97i%20chi%E1%BB%81u)%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22C%C3%B3%20padding%20%3D%201%22%0A%20%20%20%20%20%20%20%20C%5B%22Input%208%C3%978%20%2B%20padding%3Cbr%2F%3E%E2%86%92%2010%C3%9710%3Cbr%2F%3EKernel%203%C3%973%22%5D%20--%3E%20D%5B%22Output%208%C3%978%3Cbr%2F%3E(gi%E1%BB%AF%20nguy%C3%AAn%20k%C3%ADch%20th%C6%B0%E1%BB%9Bc)%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20style%20B%20fill%3A%23ffcdd2%0A%20%20%20%20style%20D%20fill%3A%23c8e6c9%0A"})]),fallback:t(()=>[...n[5]||(n[5]=[h(" Loading... ",-1)])]),_:1})),n[26]||(n[26]=i("p",null,[i("strong",null,"Quy tắc thực hành:"),h(" Để giữ nguyên kích thước không gian, đặt padding = (k-1)/2 với kernel kích thước k (k lẻ). Ví dụ: kernel 3×3 cần padding = 1, kernel 5×5 cần padding = 2.")],-1)),n[27]||(n[27]=i("h3",{id:"_2-3-3-stride-buoc-nhay",tabindex:"-1"},[h("2.3.3. Stride (Bước nhảy) "),i("a",{class:"header-anchor",href:"#_2-3-3-stride-buoc-nhay","aria-label":'Permalink to "2.3.3. Stride (Bước nhảy)"'},"​")],-1)),n[28]||(n[28]=i("p",null,[i("strong",null,"Stride"),h(" xác định số pixel mà kernel di chuyển sau mỗi bước tính toán. Stride = 1 nghĩa là kernel trượt từng pixel một; stride = 2 nghĩa là kernel nhảy 2 pixel mỗi bước, làm giảm kích thước output xuống còn một nửa theo mỗi chiều.")],-1)),n[29]||(n[29]=i("p",null,[i("strong",null,"Công thức tổng quát với cả padding và stride:")],-1)),n[30]||(n[30]=i("p",null,"⌊(n_h - k_h + p_h + s_h) / s_h⌋ × ⌊(n_w - k_w + p_w + s_w) / s_w⌋",-1)),(a(),r(l,null,{default:t(()=>[c(o,{id:"mermaid-193",class:"mermaid",graph:"graph%20LR%0A%20%20%20%20subgraph%20%22Stride%20%3D%201%22%0A%20%20%20%20%20%20%20%20A1%5B%22Input%204%C3%974%22%5D%20--%3E%20B1%5B%22Kernel%202%C3%972%3Cbr%2F%3Etr%C6%B0%E1%BB%A3t%20t%E1%BB%ABng%20pixel%22%5D%0A%20%20%20%20%20%20%20%20B1%20--%3E%20C1%5B%22Output%203%C3%973%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22Stride%20%3D%202%22%0A%20%20%20%20%20%20%20%20A2%5B%22Input%204%C3%974%22%5D%20--%3E%20B2%5B%22Kernel%202%C3%972%3Cbr%2F%3Enh%E1%BA%A3y%202%20pixel%22%5D%0A%20%20%20%20%20%20%20%20B2%20--%3E%20C2%5B%22Output%202%C3%972%3Cbr%2F%3E(gi%E1%BA%A3m%201%2F2)%22%5D%0A%20%20%20%20end%0A"})]),fallback:t(()=>[...n[6]||(n[6]=[h(" Loading... ",-1)])]),_:1})),n[31]||(n[31]=i("p",null,"Trong các kiến trúc hiện đại, stride > 1 thường được sử dụng để giảm kích thước không gian thay cho pooling (gọi là strided convolution), cho phép mạng học cách downsampling tối ưu thay vì sử dụng phép toán cố định.",-1)),n[32]||(n[32]=i("h3",{id:"_2-3-4-xu-ly-đa-kenh-multiple-channels",tabindex:"-1"},[h("2.3.4. Xử lý Đa kênh (Multiple Channels) "),i("a",{class:"header-anchor",href:"#_2-3-4-xu-ly-đa-kenh-multiple-channels","aria-label":'Permalink to "2.3.4. Xử lý Đa kênh (Multiple Channels)"'},"​")],-1)),n[33]||(n[33]=i("p",null,[h("Ảnh thực tế thường có nhiều kênh: ảnh RGB có 3 kênh, ảnh vệ tinh đa phổ có thể có từ 4 đến 13 kênh hoặc hơn. Để xử lý input có c_i kênh, kernel phải có cùng số kênh: "),i("strong",null,"c_i × k_h × k_w"),h(".")],-1)),(a(),r(l,null,{default:t(()=>[c(o,{id:"mermaid-203",class:"mermaid",graph:"graph%20TB%0A%20%20%20%20subgraph%20%22Input%3A%203%20k%C3%AAnh%20(RGB)%22%0A%20%20%20%20%20%20%20%20R%5B%22K%C3%AAnh%20R%3Cbr%2F%3EH%C3%97W%22%5D%0A%20%20%20%20%20%20%20%20G%5B%22K%C3%AAnh%20G%3Cbr%2F%3EH%C3%97W%22%5D%0A%20%20%20%20%20%20%20%20B%5B%22K%C3%AAnh%20B%3Cbr%2F%3EH%C3%97W%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22Kernel%3A%203%C3%97k%C3%97k%22%0A%20%20%20%20%20%20%20%20KR%5B%22Kernel%20R%3Cbr%2F%3Ek%C3%97k%22%5D%0A%20%20%20%20%20%20%20%20KG%5B%22Kernel%20G%3Cbr%2F%3Ek%C3%97k%22%5D%0A%20%20%20%20%20%20%20%20KB%5B%22Kernel%20B%3Cbr%2F%3Ek%C3%97k%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22X%E1%BB%AD%20l%C3%BD%22%0A%20%20%20%20%20%20%20%20P%5B%22T%C3%ADch%20ch%E1%BA%ADp%20t%E1%BB%ABng%20k%C3%AAnh%3Cbr%2F%3E%E2%86%92%20C%E1%BB%99ng%20k%E1%BA%BFt%20qu%E1%BA%A3%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22Output%22%0A%20%20%20%20%20%20%20%20O%5B%221%20Feature%20Map%3Cbr%2F%3E(H-k%2B1)%C3%97(W-k%2B1)%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20R%20--%3E%20KR%20--%3E%20P%0A%20%20%20%20G%20--%3E%20KG%20--%3E%20P%0A%20%20%20%20B%20--%3E%20KB%20--%3E%20P%0A%20%20%20%20P%20--%3E%20O%0A"})]),fallback:t(()=>[...n[7]||(n[7]=[h(" Loading... ",-1)])]),_:1})),n[34]||(n[34]=g('<p>Để tạo nhiều feature map đầu ra (c_o kênh), ta sử dụng c_o bộ kernel riêng biệt. Tổng số tham số của một lớp convolution là: <strong>c_o × c_i × k_h × k_w + c_o</strong> (bao gồm cả bias).</p><h3 id="_2-3-5-tich-chap-1×1" tabindex="-1">2.3.5. Tích chập 1×1 <a class="header-anchor" href="#_2-3-5-tich-chap-1×1" aria-label="Permalink to &quot;2.3.5. Tích chập 1×1&quot;">​</a></h3><p>Mặc dù thoạt nhìn có vẻ không có ý nghĩa vì không tổng hợp thông tin không gian, tích chập 1×1 đóng vai trò quan trọng trong các kiến trúc CNN hiện đại [1]:</p><ul><li><strong>Thay đổi số kênh:</strong> Chuyển từ c_i kênh sang c_o kênh một cách hiệu quả</li><li><strong>Kết hợp thông tin đa kênh:</strong> Mỗi pixel output là tổ hợp tuyến tính của c_i giá trị từ các kênh input tại cùng vị trí</li><li><strong>Tương đương fully connected theo pixel:</strong> Áp dụng cùng phép biến đổi tuyến tính cho mọi vị trí không gian, cho phép tăng hoặc giảm chiều biểu diễn</li></ul>',4)),(a(),r(l,null,{default:t(()=>[c(o,{id:"mermaid-230",class:"mermaid",graph:"graph%20LR%0A%20%20%20%20A%5B%22Input%3Cbr%2F%3EH%C3%97W%C3%97256%22%5D%20--%3E%20B%5B%22Conv%201%C3%971%3Cbr%2F%3E256%E2%86%9264%20k%C3%AAnh%22%5D%0A%20%20%20%20B%20--%3E%20C%5B%22Output%3Cbr%2F%3EH%C3%97W%C3%9764%22%5D%0A%0A%20%20%20%20D%5B%22S%E1%BB%91%20tham%20s%E1%BB%91%3A%3Cbr%2F%3E256%C3%9764%20%2B%2064%20%3D%2016%2C448%22%5D%0A"})]),fallback:t(()=>[...n[8]||(n[8]=[h(" Loading... ",-1)])]),_:1})),n[35]||(n[35]=g('<h2 id="_2-4-lop-pooling" tabindex="-1">2.4. Lớp Pooling <a class="header-anchor" href="#_2-4-lop-pooling" aria-label="Permalink to &quot;2.4. Lớp Pooling&quot;">​</a></h2><h3 id="_2-4-1-muc-đich-va-nguyen-ly" tabindex="-1">2.4.1. Mục đích và Nguyên lý <a class="header-anchor" href="#_2-4-1-muc-đich-va-nguyen-ly" aria-label="Permalink to &quot;2.4.1. Mục đích và Nguyên lý&quot;">​</a></h3><p>Lớp pooling thực hiện phép giảm mẫu (downsampling), thu nhỏ kích thước không gian của feature map trong khi giữ lại thông tin quan trọng nhất. Pooling phục vụ ba mục đích chính [1]:</p><ol><li><strong>Giảm chi phí tính toán:</strong> Giảm số lượng tham số và phép tính cho các lớp tiếp theo</li><li><strong>Mở rộng receptive field:</strong> Mỗi nơ-ron ở lớp sâu hơn có thể &quot;nhìn thấy&quot; vùng ảnh lớn hơn</li><li><strong>Tăng tính bất biến:</strong> Giảm độ nhạy cảm với các dịch chuyển nhỏ của đối tượng trong ảnh</li></ol><p><strong>Đặc điểm quan trọng:</strong> Khác với lớp convolution, pooling không có tham số học được. Nó áp dụng một phép toán cố định (max hoặc average) lên từng vùng của input. Số kênh output bằng số kênh input vì pooling xử lý từng kênh độc lập.</p><h3 id="_2-4-2-max-pooling-va-average-pooling" tabindex="-1">2.4.2. Max Pooling và Average Pooling <a class="header-anchor" href="#_2-4-2-max-pooling-va-average-pooling" aria-label="Permalink to &quot;2.4.2. Max Pooling và Average Pooling&quot;">​</a></h3>',6)),(a(),r(l,null,{default:t(()=>[c(o,{id:"mermaid-263",class:"mermaid",graph:"graph%20TB%0A%20%20%20%20subgraph%20%22Input%204%C3%974%22%0A%20%20%20%20%20%20%20%20I%5B%221%20%202%20%20%7C%20%203%20%204%3Cbr%2F%3E5%20%206%20%20%7C%20%207%20%208%3Cbr%2F%3E-----------%3Cbr%2F%3E9%20%2010%20%7C%2011%2012%3Cbr%2F%3E13%2014%20%7C%2015%2016%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22Max%20Pooling%202%C3%972%2C%20stride%202%22%0A%20%20%20%20%20%20%20%20M%5B%22Ch%E1%BB%8Dn%20gi%C3%A1%20tr%E1%BB%8B%20l%E1%BB%9Bn%20nh%E1%BA%A5t%3Cbr%2F%3Em%E1%BB%97i%20v%C3%B9ng%202%C3%972%22%5D%0A%20%20%20%20%20%20%20%20MO%5B%226%20%20%208%3Cbr%2F%3E14%20%2016%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22Avg%20Pooling%202%C3%972%2C%20stride%202%22%0A%20%20%20%20%20%20%20%20A%5B%22T%C3%ADnh%20trung%20b%C3%ACnh%3Cbr%2F%3Em%E1%BB%97i%20v%C3%B9ng%202%C3%972%22%5D%0A%20%20%20%20%20%20%20%20AO%5B%223.5%20%205.5%3Cbr%2F%3E11.5%2013.5%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20I%20--%3E%20M%20--%3E%20MO%0A%20%20%20%20I%20--%3E%20A%20--%3E%20AO%0A"})]),fallback:t(()=>[...n[9]||(n[9]=[h(" Loading... ",-1)])]),_:1})),n[36]||(n[36]=i("p",null,[i("strong",null,"Max Pooling"),h(" chọn giá trị lớn nhất trong mỗi vùng pooling, giữ lại activation mạnh nhất. Phương pháp này phù hợp khi quan tâm đến sự tồn tại của đặc trưng tại một vùng nhất định và tạo tính bất biến với các dịch chuyển nhỏ.")],-1)),n[37]||(n[37]=i("p",null,[i("strong",null,"Average Pooling"),h(" tính giá trị trung bình của các phần tử trong vùng pooling, giữ lại thông tin tổng thể về cường độ đặc trưng. Phương pháp này phù hợp cho việc tổng hợp ngữ cảnh và thường được sử dụng ở cuối mạng.")],-1)),n[38]||(n[38]=i("h3",{id:"_2-4-3-global-average-pooling-gap",tabindex:"-1"},[h("2.4.3. Global Average Pooling (GAP) "),i("a",{class:"header-anchor",href:"#_2-4-3-global-average-pooling-gap","aria-label":'Permalink to "2.4.3. Global Average Pooling (GAP)"'},"​")],-1)),n[39]||(n[39]=i("p",null,"Global Average Pooling tính trung bình trên toàn bộ feature map cho mỗi kênh, tạo ra output có kích thước 1×1×C (với C là số kênh). Kỹ thuật này được giới thiệu trong Network in Network [6] và được sử dụng rộng rãi trong các kiến trúc hiện đại.",-1)),(a(),r(l,null,{default:t(()=>[c(o,{id:"mermaid-276",class:"mermaid",graph:"graph%20LR%0A%20%20%20%20A%5B%22Feature%20Map%3Cbr%2F%3E7%C3%977%C3%97512%22%5D%20--%3E%20B%5B%22Global%20Average%3Cbr%2F%3EPooling%22%5D%0A%20%20%20%20B%20--%3E%20C%5B%22Vector%3Cbr%2F%3E1%C3%971%C3%97512%22%5D%0A%20%20%20%20C%20--%3E%20D%5B%22FC%20ho%E1%BA%B7c%3Cbr%2F%3EConv%201%C3%971%22%5D%0A%20%20%20%20D%20--%3E%20E%5B%22S%E1%BB%91%20l%E1%BB%9Bp%3Cbr%2F%3Eph%C3%A2n%20lo%E1%BA%A1i%22%5D%0A"})]),fallback:t(()=>[...n[10]||(n[10]=[h(" Loading... ",-1)])]),_:1})),n[40]||(n[40]=g('<p>GAP mang lại nhiều lợi ích quan trọng:</p><ul><li><strong>Giảm đáng kể số tham số</strong> so với việc sử dụng các lớp fully connected lớn</li><li><strong>Tránh overfitting</strong> nhờ loại bỏ phần lớn tham số ở phần classifier</li><li><strong>Cho phép xử lý ảnh với kích thước bất kỳ</strong> vì không phụ thuộc vào kích thước không gian cố định</li></ul><h2 id="_2-5-ham-kich-hoat-activation-function" tabindex="-1">2.5. Hàm Kích hoạt (Activation Function) <a class="header-anchor" href="#_2-5-ham-kich-hoat-activation-function" aria-label="Permalink to &quot;2.5. Hàm Kích hoạt (Activation Function)&quot;">​</a></h2><h3 id="_2-5-1-vai-tro-cua-ham-kich-hoat" tabindex="-1">2.5.1. Vai trò của Hàm Kích hoạt <a class="header-anchor" href="#_2-5-1-vai-tro-cua-ham-kich-hoat" aria-label="Permalink to &quot;2.5.1. Vai trò của Hàm Kích hoạt&quot;">​</a></h3><p>Hàm kích hoạt đóng vai trò thiết yếu trong việc thêm tính phi tuyến vào mạng nơ-ron. Nếu không có hàm kích hoạt phi tuyến, việc xếp chồng nhiều lớp convolution hay fully connected sẽ chỉ tương đương với một phép biến đổi tuyến tính duy nhất:</p><p>f(g(x)) = Ax + b (nếu cả f và g đều tuyến tính)</p><p>Với hàm kích hoạt phi tuyến, mạng có thể xấp xỉ các hàm phức tạp tùy ý theo định lý universal approximation, mở ra khả năng học các biểu diễn phức tạp từ dữ liệu.</p><h3 id="_2-5-2-relu-va-cac-bien-the" tabindex="-1">2.5.2. ReLU và các biến thể <a class="header-anchor" href="#_2-5-2-relu-va-cac-bien-the" aria-label="Permalink to &quot;2.5.2. ReLU và các biến thể&quot;">​</a></h3>',8)),(a(),r(l,null,{default:t(()=>[c(o,{id:"mermaid-315",class:"mermaid",graph:"graph%20TB%0A%20%20%20%20subgraph%20%22ReLU%3A%20f(x)%20%3D%20max(0%2C%20x)%22%0A%20%20%20%20%20%20%20%20R%5B%22x%20%3C%200%20%E2%86%92%200%3Cbr%2F%3Ex%20%E2%89%A5%200%20%E2%86%92%20x%22%5D%0A%20%20%20%20%20%20%20%20R1%5B%22%C6%AFu%3A%20%C4%90%C6%A1n%20gi%E1%BA%A3n%2C%20tr%C3%A1nh%20vanishing%20gradient%3Cbr%2F%3ENh%C6%B0%E1%BB%A3c%3A%20Dying%20ReLU%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22Leaky%20ReLU%3A%20f(x)%20%3D%20max(%CE%B1x%2C%20x)%22%0A%20%20%20%20%20%20%20%20L%5B%22x%20%3C%200%20%E2%86%92%200.01x%3Cbr%2F%3Ex%20%E2%89%A5%200%20%E2%86%92%20x%22%5D%0A%20%20%20%20%20%20%20%20L1%5B%22%C6%AFu%3A%20Tr%C3%A1nh%20dying%20ReLU%3Cbr%2F%3E%CE%B1%20th%C6%B0%E1%BB%9Dng%20%3D%200.01%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22PReLU%22%0A%20%20%20%20%20%20%20%20P%5B%22x%20%3C%200%20%E2%86%92%20%CE%B1x%20(%CE%B1%20h%E1%BB%8Dc%20%C4%91%C6%B0%E1%BB%A3c)%3Cbr%2F%3Ex%20%E2%89%A5%200%20%E2%86%92%20x%22%5D%0A%20%20%20%20%20%20%20%20P1%5B%22%C6%AFu%3A%20%CE%B1%20%C4%91%C6%B0%E1%BB%A3c%20t%E1%BB%91i%20%C6%B0u%20t%E1%BB%AB%20d%E1%BB%AF%20li%E1%BB%87u%22%5D%0A%20%20%20%20end%0A"})]),fallback:t(()=>[...n[11]||(n[11]=[h(" Loading... ",-1)])]),_:1})),n[41]||(n[41]=g('<p><strong>ReLU (Rectified Linear Unit)</strong> là hàm kích hoạt được sử dụng phổ biến nhất trong các CNN hiện đại [3] nhờ các ưu điểm:</p><ul><li><strong>Tính toán đơn giản:</strong> Chỉ cần thực hiện phép so sánh với 0</li><li><strong>Giảm vấn đề vanishing gradient:</strong> Gradient bằng 1 khi x &gt; 0, cho phép gradient truyền ngược hiệu quả</li><li><strong>Tạo sparse activation:</strong> Nhiều output bằng 0, giúp biểu diễn hiệu quả và tiết kiệm tính toán</li></ul><p><strong>Nhược điểm &quot;Dying ReLU&quot;:</strong> Nếu input luôn âm (do khởi tạo trọng số không phù hợp hoặc learning rate quá lớn), gradient sẽ bằng 0 và nơ-ron không thể cập nhật được nữa, dẫn đến hiện tượng nơ-ron &quot;chết&quot; vĩnh viễn.</p><p><strong>Leaky ReLU</strong> và <strong>PReLU</strong> được đề xuất để khắc phục vấn đề này bằng cách cho phép một gradient nhỏ khi x &lt; 0, đảm bảo nơ-ron luôn có thể được cập nhật.</p><h3 id="_2-5-3-ham-sigmoid-va-softmax" tabindex="-1">2.5.3. Hàm Sigmoid và Softmax <a class="header-anchor" href="#_2-5-3-ham-sigmoid-va-softmax" aria-label="Permalink to &quot;2.5.3. Hàm Sigmoid và Softmax&quot;">​</a></h3><p><strong>Sigmoid:</strong> σ(x) = 1 / (1 + e^(-x))</p><ul><li>Output nằm trong khoảng (0, 1), thích hợp cho việc biểu diễn xác suất</li><li>Thường được sử dụng cho bài toán phân loại nhị phân (binary classification)</li><li>Nhược điểm: Gặp vấn đề vanishing gradient khi |x| lớn, làm chậm quá trình học</li></ul><p><strong>Softmax:</strong> Biến đổi vector z thành phân phối xác suất:</p><ul><li>softmax(z_i) = e^(z_i) / Σ e^(z_j)</li><li>Tổng các xác suất bằng 1, cho phép diễn giải output như xác suất thuộc từng lớp</li><li>Được sử dụng ở lớp cuối cùng cho bài toán phân loại đa lớp (multi-class classification)</li></ul><h3 id="_2-5-4-ham-kich-hoat-hien-đai-gelu-va-swish" tabindex="-1">2.5.4. Hàm kích hoạt hiện đại: GELU và Swish <a class="header-anchor" href="#_2-5-4-ham-kich-hoat-hien-đai-gelu-va-swish" aria-label="Permalink to &quot;2.5.4. Hàm kích hoạt hiện đại: GELU và Swish&quot;">​</a></h3><p><strong>GELU (Gaussian Error Linear Unit)</strong> kết hợp tính chất của ReLU với một hàm mịn, được sử dụng rộng rãi trong các mô hình Transformer như BERT và Vision Transformer [7]. GELU có thể được xấp xỉ bằng công thức: GELU(x) ≈ 0.5x(1 + tanh(√(2/π)(x + 0.044715x³)))</p><p><strong>Swish</strong> được định nghĩa là f(x) = x × σ(x), tự động điều chỉnh giữa hành vi tuyến tính và phi tuyến tùy thuộc vào giá trị input. Hàm này cho kết quả tốt trên nhiều kiến trúc, đặc biệt là EfficientNet [8].</p><h2 id="_2-6-batch-normalization" tabindex="-1">2.6. Batch Normalization <a class="header-anchor" href="#_2-6-batch-normalization" aria-label="Permalink to &quot;2.6. Batch Normalization&quot;">​</a></h2><h3 id="_2-6-1-van-đe-internal-covariate-shift" tabindex="-1">2.6.1. Vấn đề Internal Covariate Shift <a class="header-anchor" href="#_2-6-1-van-đe-internal-covariate-shift" aria-label="Permalink to &quot;2.6.1. Vấn đề Internal Covariate Shift&quot;">​</a></h3><p>Trong quá trình huấn luyện mạng sâu, phân phối của input tại mỗi lớp thay đổi liên tục theo sự cập nhật của các lớp trước đó. Hiện tượng này được gọi là <strong>internal covariate shift</strong> [4], gây khó khăn cho quá trình học vì mỗi lớp phải liên tục thích nghi với phân phối input mới thay vì tập trung vào việc học các đặc trưng hữu ích.</p><h3 id="_2-6-2-co-che-batch-normalization" tabindex="-1">2.6.2. Cơ chế Batch Normalization <a class="header-anchor" href="#_2-6-2-co-che-batch-normalization" aria-label="Permalink to &quot;2.6.2. Cơ chế Batch Normalization&quot;">​</a></h3><p>Batch Normalization (BN) được đề xuất bởi Ioffe và Szegedy [4] như một giải pháp cho vấn đề trên. BN chuẩn hóa activation của mỗi lớp theo mean và variance của mini-batch hiện tại, sau đó áp dụng phép biến đổi tuyến tính với các tham số học được:</p>',17)),(a(),r(l,null,{default:t(()=>[c(o,{id:"mermaid-409",class:"mermaid",graph:"graph%20TB%0A%20%20%20%20subgraph%20%22B%C6%B0%E1%BB%9Bc%201%3A%20T%C3%ADnh%20th%E1%BB%91ng%20k%C3%AA%20mini-batch%22%0A%20%20%20%20%20%20%20%20A%5B%22Input%20x%20t%E1%BB%AB%20mini-batch%22%5D%0A%20%20%20%20%20%20%20%20B%5B%22%CE%BC%20%3D%20mean(x)%3Cbr%2F%3E%CF%83%C2%B2%20%3D%20var(x)%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22B%C6%B0%E1%BB%9Bc%202%3A%20Chu%E1%BA%A9n%20h%C3%B3a%22%0A%20%20%20%20%20%20%20%20C%5B%22x%CC%82%20%3D%20(x%20-%20%CE%BC)%20%2F%20%E2%88%9A(%CF%83%C2%B2%20%2B%20%CE%B5)%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22B%C6%B0%E1%BB%9Bc%203%3A%20Scale%20v%C3%A0%20Shift%22%0A%20%20%20%20%20%20%20%20D%5B%22y%20%3D%20%CE%B3%20%C3%97%20x%CC%82%20%2B%20%CE%B2%3Cbr%2F%3E(%CE%B3%2C%20%CE%B2%20h%E1%BB%8Dc%20%C4%91%C6%B0%E1%BB%A3c)%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20A%20--%3E%20B%20--%3E%20C%20--%3E%20D%0A"})]),fallback:t(()=>[...n[12]||(n[12]=[h(" Loading... ",-1)])]),_:1})),n[42]||(n[42]=g('<p><strong>Công thức tổng quát:</strong> y = γ × (x - μ) / √(σ² + ε) + β</p><p>Trong đó:</p><ul><li><strong>μ, σ²:</strong> Mean và variance của mini-batch (trong training) hoặc running average (trong inference)</li><li><strong>ε:</strong> Hằng số nhỏ (thường 10⁻⁵) để tránh chia cho 0</li><li><strong>γ, β:</strong> Tham số scale và shift, được học từ dữ liệu, cho phép mạng khôi phục biểu diễn ban đầu nếu cần thiết</li></ul><h3 id="_2-6-3-loi-ich-cua-batch-normalization" tabindex="-1">2.6.3. Lợi ích của Batch Normalization <a class="header-anchor" href="#_2-6-3-loi-ich-cua-batch-normalization" aria-label="Permalink to &quot;2.6.3. Lợi ích của Batch Normalization&quot;">​</a></h3><p>Batch Normalization mang lại nhiều lợi ích quan trọng cho quá trình huấn luyện [4]:</p><ol><li><strong>Cho phép sử dụng learning rate lớn hơn:</strong> BN ổn định phân phối activation, giảm nguy cơ gradient exploding và cho phép tăng tốc độ học</li><li><strong>Giảm phụ thuộc vào khởi tạo trọng số:</strong> Việc chuẩn hóa làm giảm ảnh hưởng của giá trị khởi tạo ban đầu đến quá trình huấn luyện</li><li><strong>Đóng vai trò regularization:</strong> Noise từ việc ước lượng mean và variance theo mini-batch có tác dụng tương tự dropout, giúp giảm overfitting</li><li><strong>Tăng tốc convergence đáng kể:</strong> Các thực nghiệm cho thấy BN có thể giảm số lượng iterations cần thiết để đạt convergence</li></ol><p><strong>Vị trí trong kiến trúc:</strong> BN thường được đặt sau lớp convolution hoặc fully connected. Có hai cách tiếp cận phổ biến: đặt BN trước hàm kích hoạt (pre-activation, được sử dụng trong ResNet v2) hoặc sau hàm kích hoạt (post-activation, sử dụng trong kiến trúc gốc).</p><h2 id="_2-7-dropout" tabindex="-1">2.7. Dropout <a class="header-anchor" href="#_2-7-dropout" aria-label="Permalink to &quot;2.7. Dropout&quot;">​</a></h2><h3 id="_2-7-1-co-che-hoat-đong" tabindex="-1">2.7.1. Cơ chế Hoạt động <a class="header-anchor" href="#_2-7-1-co-che-hoat-đong" aria-label="Permalink to &quot;2.7.1. Cơ chế Hoạt động&quot;">​</a></h3><p>Dropout là kỹ thuật regularization được đề xuất bởi Srivastava et al. [5] nhằm giảm overfitting trong mạng nơ-ron sâu. Trong mỗi iteration huấn luyện, dropout ngẫu nhiên &quot;tắt&quot; một tỷ lệ p các nơ-ron bằng cách đặt output của chúng về 0.</p>',10)),(a(),r(l,null,{default:t(()=>[c(o,{id:"mermaid-473",class:"mermaid",graph:"graph%20LR%0A%20%20%20%20subgraph%20%22Training%3A%20Dropout%20p%3D0.5%22%0A%20%20%20%20%20%20%20%20A%5B%22Input%22%5D%20--%3E%20B%5B%22Layer%22%5D%0A%20%20%20%20%20%20%20%20B%20--%3E%20C%5B%2250%25%20neurons%3Cbr%2F%3Eb%E1%BB%8B%20t%E1%BA%AFt%20ng%E1%BA%ABu%20nhi%C3%AAn%22%5D%0A%20%20%20%20%20%20%20%20C%20--%3E%20D%5B%22Output%20%C3%97%202%3Cbr%2F%3E(scale%20up)%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22Inference%3A%20Kh%C3%B4ng%20dropout%22%0A%20%20%20%20%20%20%20%20E%5B%22Input%22%5D%20--%3E%20F%5B%22Layer%22%5D%0A%20%20%20%20%20%20%20%20F%20--%3E%20G%5B%22100%25%20neurons%3Cbr%2F%3Eho%E1%BA%A1t%20%C4%91%E1%BB%99ng%22%5D%0A%20%20%20%20%20%20%20%20G%20--%3E%20H%5B%22Output%3Cbr%2F%3E(kh%C3%B4ng%20scale)%22%5D%0A%20%20%20%20end%0A"})]),fallback:t(()=>[...n[13]||(n[13]=[h(" Loading... ",-1)])]),_:1})),n[43]||(n[43]=g('<p>Cơ chế này buộc mạng phải học các biểu diễn robust, không phụ thuộc vào bất kỳ nơ-ron cụ thể nào. Từ góc độ lý thuyết, dropout có thể được hiểu như một hình thức model averaging: mỗi lần training với một tập con nơ-ron khác nhau tương đương với việc training một mạng con khác nhau, và kết quả inference là trung bình của tất cả các mạng con này.</p><h3 id="_2-7-2-chien-luoc-su-dung-dropout" tabindex="-1">2.7.2. Chiến lược sử dụng Dropout <a class="header-anchor" href="#_2-7-2-chien-luoc-su-dung-dropout" aria-label="Permalink to &quot;2.7.2. Chiến lược sử dụng Dropout&quot;">​</a></h3><p>Tỷ lệ dropout được lựa chọn phụ thuộc vào loại lớp và kiến trúc mạng:</p><ul><li><strong>Lớp fully connected:</strong> Thường sử dụng p = 0.5 (tắt 50% nơ-ron) vì số lượng tham số lớn, dễ overfitting</li><li><strong>Lớp convolution:</strong> Thường sử dụng p nhỏ hơn (0.1 - 0.3) hoặc không sử dụng do tính chất chia sẻ trọng số đã có tác dụng regularization</li><li><strong>Kiến trúc hiện đại:</strong> Nhiều kiến trúc như ResNet và EfficientNet thay thế dropout bằng Batch Normalization kết hợp với weight decay, cho kết quả tương đương hoặc tốt hơn</li></ul><h2 id="_2-8-kien-truc-tong-the-cua-cnn" tabindex="-1">2.8. Kiến trúc Tổng thể của CNN <a class="header-anchor" href="#_2-8-kien-truc-tong-the-cua-cnn" aria-label="Permalink to &quot;2.8. Kiến trúc Tổng thể của CNN&quot;">​</a></h2><h3 id="_2-8-1-mau-kien-truc-co-đien" tabindex="-1">2.8.1. Mẫu Kiến trúc Cổ điển <a class="header-anchor" href="#_2-8-1-mau-kien-truc-co-đien" aria-label="Permalink to &quot;2.8.1. Mẫu Kiến trúc Cổ điển&quot;">​</a></h3><p>Các kiến trúc CNN cổ điển như LeNet [2] và VGGNet [3] tuân theo một mẫu thiết kế nhất quán: xen kẽ các lớp convolution với pooling, theo sau bởi các lớp fully connected để thực hiện phân loại.</p>',7)),(a(),r(l,null,{default:t(()=>[c(o,{id:"mermaid-509",class:"mermaid",graph:"graph%20TB%0A%20%20%20%20subgraph%20%22Input%22%0A%20%20%20%20%20%20%20%20I%5B%22%E1%BA%A2nh%20RGB%3Cbr%2F%3E224%C3%97224%C3%973%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22Block%201%22%0A%20%20%20%20%20%20%20%20C1%5B%22Conv%203%C3%973%2C%2064%22%5D%0A%20%20%20%20%20%20%20%20R1%5B%22ReLU%22%5D%0A%20%20%20%20%20%20%20%20P1%5B%22Max%20Pool%202%C3%972%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22Block%202%22%0A%20%20%20%20%20%20%20%20C2%5B%22Conv%203%C3%973%2C%20128%22%5D%0A%20%20%20%20%20%20%20%20R2%5B%22ReLU%22%5D%0A%20%20%20%20%20%20%20%20P2%5B%22Max%20Pool%202%C3%972%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22Block%203%22%0A%20%20%20%20%20%20%20%20C3%5B%22Conv%203%C3%973%2C%20256%22%5D%0A%20%20%20%20%20%20%20%20R3%5B%22ReLU%22%5D%0A%20%20%20%20%20%20%20%20P3%5B%22Max%20Pool%202%C3%972%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22Classification%22%0A%20%20%20%20%20%20%20%20F%5B%22Flatten%22%5D%0A%20%20%20%20%20%20%20%20FC1%5B%22FC%204096%22%5D%0A%20%20%20%20%20%20%20%20FC2%5B%22FC%201000%22%5D%0A%20%20%20%20%20%20%20%20S%5B%22Softmax%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20I%20--%3E%20C1%20--%3E%20R1%20--%3E%20P1%0A%20%20%20%20P1%20--%3E%20C2%20--%3E%20R2%20--%3E%20P2%0A%20%20%20%20P2%20--%3E%20C3%20--%3E%20R3%20--%3E%20P3%0A%20%20%20%20P3%20--%3E%20F%20--%3E%20FC1%20--%3E%20FC2%20--%3E%20S%0A"})]),fallback:t(()=>[...n[14]||(n[14]=[h(" Loading... ",-1)])]),_:1})),n[44]||(n[44]=g('<p><strong>Quy luật thiết kế chung:</strong></p><ul><li><strong>Kích thước không gian giảm dần:</strong> 224 → 112 → 56 → 28 → 14 → 7 (thường giảm một nửa sau mỗi lần pooling)</li><li><strong>Số kênh tăng dần:</strong> 3 → 64 → 128 → 256 → 512 (thường tăng gấp đôi khi giảm kích thước không gian)</li><li><strong>Biểu diễn chuyển từ chi tiết không gian sang ngữ nghĩa trừu tượng:</strong> Các lớp đầu biểu diễn đặc trưng cấp thấp (cạnh, góc), các lớp sâu biểu diễn khái niệm ngữ nghĩa cao (đối tượng, bộ phận)</li></ul><h3 id="_2-8-2-kien-truc-hien-đai" tabindex="-1">2.8.2. Kiến trúc Hiện đại <a class="header-anchor" href="#_2-8-2-kien-truc-hien-đai" aria-label="Permalink to &quot;2.8.2. Kiến trúc Hiện đại&quot;">​</a></h3><p>Các kiến trúc CNN hiện đại như ResNet [9], Inception [10], và EfficientNet [8] đã đưa ra nhiều cải tiến quan trọng so với mẫu cổ điển:</p><ul><li><strong>Skip connection (Residual connection):</strong> Cho phép gradient chảy trực tiếp qua nhiều lớp, giải quyết vấn đề vanishing gradient và cho phép huấn luyện mạng rất sâu (hàng trăm đến hàng nghìn lớp)</li><li><strong>Bottleneck block:</strong> Sử dụng Conv 1×1 để giảm số kênh trước khi thực hiện Conv 3×3 tốn kém, sau đó tăng lại số kênh, giảm đáng kể chi phí tính toán</li><li><strong>Global Average Pooling:</strong> Thay thế các lớp fully connected lớn ở cuối mạng, giảm số tham số và tránh overfitting</li><li><strong>Compound scaling:</strong> Cân bằng đồng thời ba chiều (độ sâu, độ rộng, và độ phân giải) để đạt hiệu quả tối ưu với một lượng tài nguyên tính toán cho trước</li></ul><p>Chi tiết các kiến trúc backbone này được trình bày trong Mục 2.2.</p><h2 id="_2-9-qua-trinh-huan-luyen-cnn" tabindex="-1">2.9. Quá trình Huấn luyện CNN <a class="header-anchor" href="#_2-9-qua-trinh-huan-luyen-cnn" aria-label="Permalink to &quot;2.9. Quá trình Huấn luyện CNN&quot;">​</a></h2><h3 id="_2-9-1-forward-va-backward-propagation" tabindex="-1">2.9.1. Forward và Backward Propagation <a class="header-anchor" href="#_2-9-1-forward-va-backward-propagation" aria-label="Permalink to &quot;2.9.1. Forward và Backward Propagation&quot;">​</a></h3><p>Quá trình huấn luyện CNN bao gồm hai giai đoạn chính được thực hiện lặp đi lặp lại: forward propagation và backward propagation.</p>',9)),(a(),r(l,null,{default:t(()=>[c(o,{id:"mermaid-570",class:"mermaid",graph:"graph%20LR%0A%20%20%20%20subgraph%20%22Forward%20Pass%22%0A%20%20%20%20%20%20%20%20X%5B%22Input%20X%22%5D%20--%3E%20L1%5B%22Layer%201%3Cbr%2F%3Ey%E2%82%81%20%3D%20f%E2%82%81(X)%22%5D%0A%20%20%20%20%20%20%20%20L1%20--%3E%20L2%5B%22Layer%202%3Cbr%2F%3Ey%E2%82%82%20%3D%20f%E2%82%82(y%E2%82%81)%22%5D%0A%20%20%20%20%20%20%20%20L2%20--%3E%20LN%5B%22...%3Cbr%2F%3E%C5%B7%20%3D%20f%E2%82%99(...)%22%5D%0A%20%20%20%20%20%20%20%20LN%20--%3E%20Loss%5B%22Loss%20L(%C5%B7%2C%20y)%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22Backward%20Pass%22%0A%20%20%20%20%20%20%20%20Loss%20--%3E%20%7C%22%E2%88%82L%2F%E2%88%82%C5%B7%22%7C%20LN%0A%20%20%20%20%20%20%20%20LN%20--%3E%20%7C%22%E2%88%82L%2F%E2%88%82y%E2%82%82%22%7C%20L2%0A%20%20%20%20%20%20%20%20L2%20--%3E%20%7C%22%E2%88%82L%2F%E2%88%82y%E2%82%81%22%7C%20L1%0A%20%20%20%20%20%20%20%20L1%20--%3E%20%7C%22%E2%88%82L%2F%E2%88%82X%22%7C%20X%0A%20%20%20%20end%0A"})]),fallback:t(()=>[...n[15]||(n[15]=[h(" Loading... ",-1)])]),_:1})),n[45]||(n[45]=g('<p><strong>Forward propagation</strong> là quá trình tính toán output của mạng từ input đầu vào. Dữ liệu được truyền qua từng lớp theo thứ tự, với output của lớp trước trở thành input của lớp sau. Tại mỗi lớp, các phép biến đổi tương ứng (convolution, activation, pooling, v.v.) được thực hiện cho đến khi thu được output cuối cùng.</p><p><strong>Backward propagation</strong> (hay backpropagation) là quá trình tính toán gradient của loss function theo từng tham số trong mạng bằng cách áp dụng chain rule. Gradient được tính toán từ lớp cuối cùng và truyền ngược về lớp đầu tiên, cho phép xác định hướng cập nhật tối ưu cho mỗi tham số.</p><h3 id="_2-9-2-ham-loss-loss-function" tabindex="-1">2.9.2. Hàm Loss (Loss Function) <a class="header-anchor" href="#_2-9-2-ham-loss-loss-function" aria-label="Permalink to &quot;2.9.2. Hàm Loss (Loss Function)&quot;">​</a></h3><p>Hàm loss đo lường sự khác biệt giữa output dự đoán của mạng và nhãn thực tế (ground truth), cung cấp tín hiệu để điều chỉnh các tham số trong quá trình học.</p><p><strong>Cross-Entropy Loss</strong> là hàm loss được sử dụng phổ biến nhất cho bài toán phân loại đa lớp:</p><p>L = -Σᵢ yᵢ × log(pᵢ)</p><p>Trong đó:</p><ul><li><strong>yᵢ:</strong> One-hot encoding của nhãn thực tế (1 cho lớp đúng, 0 cho các lớp khác)</li><li><strong>pᵢ:</strong> Xác suất dự đoán cho lớp i (output của softmax)</li></ul><p>Cross-Entropy Loss có tính chất phạt nặng các dự đoán sai với độ tin cậy cao, khuyến khích mô hình đưa ra các dự đoán chính xác và đáng tin cậy.</p><p>Đối với các bài toán khác trong viễn thám như phát hiện đối tượng và phân đoạn ngữ nghĩa, các hàm loss phức tạp hơn được sử dụng, bao gồm:</p><ul><li><strong>Focal Loss:</strong> Giải quyết vấn đề mất cân bằng lớp trong object detection</li><li><strong>Dice Loss và IoU Loss:</strong> Tối ưu trực tiếp các metric đánh giá cho segmentation</li><li><strong>Smooth L1 Loss:</strong> Sử dụng cho bounding box regression trong object detection</li></ul><h3 id="_2-9-3-thuat-toan-optimization" tabindex="-1">2.9.3. Thuật toán Optimization <a class="header-anchor" href="#_2-9-3-thuat-toan-optimization" aria-label="Permalink to &quot;2.9.3. Thuật toán Optimization&quot;">​</a></h3><p>Sau khi tính được gradient, các thuật toán optimization sử dụng thông tin này để cập nhật tham số theo hướng giảm loss.</p><p><strong>Stochastic Gradient Descent (SGD) với Momentum</strong> là thuật toán cổ điển nhưng vẫn hiệu quả. Momentum giúp tích lũy &quot;đà&quot; từ các bước trước, giúp vượt qua các local minima nhỏ và tăng tốc convergence:</p><p>v_t = β × v_{t-1} + η × ∇L θ_t = θ_{t-1} - v_t</p><p>Trong đó β là hệ số momentum (thường 0.9) và η là learning rate.</p><p><strong>Adam (Adaptive Moment Estimation)</strong> kết hợp ưu điểm của momentum với adaptive learning rate cho từng tham số. Adam duy trì ước lượng của cả moment bậc một (mean) và bậc hai (variance) của gradient, cho phép điều chỉnh learning rate phù hợp với từng tham số. Thuật toán này đặc biệt hiệu quả cho các bài toán với gradient thưa hoặc noisy.</p><p><strong>Learning Rate Scheduling</strong> là kỹ thuật quan trọng để đạt convergence tốt. Các chiến lược phổ biến bao gồm:</p><ul><li><strong>Step decay:</strong> Giảm learning rate theo các bước cố định (ví dụ: giảm 10 lần sau mỗi 30 epochs)</li><li><strong>Cosine annealing:</strong> Giảm learning rate theo hàm cosine, cho phép &quot;warm restart&quot; để thoát khỏi local minima</li><li><strong>Warmup:</strong> Bắt đầu với learning rate nhỏ và tăng dần trong một số iterations đầu, giúp ổn định quá trình training ban đầu</li></ul><p><strong>Weight Decay (L2 Regularization)</strong> thêm penalty cho các trọng số có giá trị lớn, giúp tránh overfitting:</p><p>L_total = L_data + λ × ||W||²</p><p>Trong đó λ là hệ số regularization, kiểm soát độ mạnh của penalty. Weight decay được sử dụng rộng rãi trong hầu hết các kiến trúc CNN hiện đại.</p><hr><h2 id="tai-lieu-tham-khao" tabindex="-1">Tài liệu Tham khảo <a class="header-anchor" href="#tai-lieu-tham-khao" aria-label="Permalink to &quot;Tài liệu Tham khảo&quot;">​</a></h2><p>[1] Zhang, A., Lipton, Z. C., Li, M., &amp; Smola, A. J. (2023). Dive into Deep Learning. Cambridge University Press. <a href="https://d2l.ai/" target="_blank" rel="noreferrer">https://d2l.ai/</a></p><p>[2] LeCun, Y., Bottou, L., Bengio, Y., &amp; Haffner, P. (1998). Gradient-based learning applied to document recognition. <em>Proceedings of the IEEE</em>, 86(11), 2278-2324.</p><p>[3] Simonyan, K., &amp; Zisserman, A. (2015). Very Deep Convolutional Networks for Large-Scale Image Recognition. In <em>Proceedings of ICLR 2015</em>.</p><p>[4] Ioffe, S., &amp; Szegedy, C. (2015). Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift. In <em>Proceedings of ICML 2015</em>.</p><p>[5] Srivastava, N., Hinton, G., Krizhevsky, A., Sutskever, I., &amp; Salakhutdinov, R. (2014). Dropout: A Simple Way to Prevent Neural Networks from Overfitting. <em>Journal of Machine Learning Research</em>, 15, 1929-1958.</p><p>[6] Lin, M., Chen, Q., &amp; Yan, S. (2014). Network In Network. In <em>Proceedings of ICLR 2014</em>.</p><p>[7] Hendrycks, D., &amp; Gimpel, K. (2016). Gaussian Error Linear Units (GELUs). <em>arXiv preprint arXiv:1606.08415</em>.</p><p>[8] Tan, M., &amp; Le, Q. V. (2019). EfficientNet: Rethinking Model Scaling for Convolutional Neural Networks. In <em>Proceedings of ICML 2019</em>.</p><p>[9] He, K., Zhang, X., Ren, S., &amp; Sun, J. (2016). Deep Residual Learning for Image Recognition. In <em>Proceedings of CVPR 2016</em>.</p><p>[10] Szegedy, C., et al. (2015). Going Deeper with Convolutions. In <em>Proceedings of CVPR 2015</em>.</p>',34))])}const E=e(s,[["render",d]]);export{k as __pageData,E as default};
